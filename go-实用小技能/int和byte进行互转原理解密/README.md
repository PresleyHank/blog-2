  我们在进行网络编程的时候，都会遇到大小端模式的问题。刚开始接触的时候我也比较懵逼，大端小端，什么鬼？网上说的很多术语都看不明白。其实按照我个人的理解，大端模式就是和我们阅读现代文学一样，一般都是从左到右进行阅读。而小端模式就像在阅读古代的武功秘籍一样，是从右往左进行学习的。

  当然我今天不会去讲为什么存在大小端这种不同的模式，只要在我们进行int和byte进行互转的时候，知道有这么个概念就可以了。

  在go语言中的byte的存储方式和java的不一样。java的byte是有符号的，而go的byte是使用无符号进行存储的。通过查看go源代码我们知道byte其实是uint8的别名，也就是说byte在存储的时候占用了8个字节，byte和uint8之间不需要任何的操作就可以直接进行互转。

>// byte is an alias for uint8 and is equivalent to uint8 in all ways. It is
>// used, by convention, to distinguish byte values from 8-bit unsigned
>// integer values.
>type byte byte

接下来一步一步去验证刚刚我们的推理是否正确。首先我们知道uint8取值范围是0~255，那么我们先将0~255这个范围的int转成byte
```
func f1() {
	var v1 uint32
	v1 = 255
	fmt.Println(byte(v1))
}

```
  上面的代码运行结果为：255，和我们想的是一样的，byte 和 uint8 之间可以直接进行互转。目前来只能将0~255范围的int转成byte。因为超出这个范围，go在转换的时候，就会把多出来数据扔掉。
  
  现在得想个办法将大于255的数字转成byte可接受的范围？

  聪明的小伙伴应该想到了。一个byte只能放255，如果超过255再加一个byte不就行了。^>^ 没错，其实我们可以使用[]byte数组来解决这个问题。一个byte最大值255，表示成二进制就是：1111 1111。两个byte最大值为65535，表示成二进制就是：1111 1111 1111 1111，两个byte刚好占16位字节和uint16一样。同理。三个byte最大值为：16777215， 表示成二进制就是：1111 1111 1111 1111 1111 1111。四个byte就是4294967295，二进制表示为：1111 1111 1111 1111 1111 1111 1111 1111。

  通过上面分析可以得出，如果需要将int32转成byte类型，我们只需要一个长度为4的[]byte数组就可以了,现在还有最后一个难点就是对int数据进行拆分。将0~255区间的数据放在下标为3的位置。将256~65535区间的数据放在下标为2的位置，将65536~16777215区间的数据放在下标为1的位置，将16777216~4294967295区间的数据放在下标为0的位置。这里可能比较晕，下面直接看代码可能就会明白了
  

  ```

// 这里是大端模式
func f2() {
	var v2 uint32
	var b2 [4]byte
	v2 = 257
	// 将 256转成二进制就是
	// | 00000000 | 00000000 | 00000001 | 00000001 |
	// | b2[0]    | b2[1]   | b2[2]    | [3]      | // 这里表示b2数组每个下标里面存放的值

	// 这里直接使用将uint32l强转成uint8
	// | 00000000 0000000 00000001 | 00000001  直接转成uint8后等于 1
	// |---这部分go在强转的时候扔掉---|
	b2[3] = uint8(v2)

	// | 00000000 | 00000000 | 00000001 | 00000001 | 右移8位 转成uint8后等于 1
	// 下面是右移后的数据
	// |          | 00000000 | 00000000 | 00000001 |
	b2[2] = uint8(v2 >> 8)

	// | 00000000 | 00000000 | 00000001 | 00000001 | 右移16位 转成uint8后等于 0
	// 下面是右移后的数据
	// |          |          | 00000000 | 00000000 |
	b2[1] = uint8(v2 >> 16)

	// | 00000000 | 00000000 | 00000001 | 00000001 | 右移24位 转成uint8后等于 0
	// 下面是右移后的数据
	// |          |          |          | 00000000 |
	b2[0] = uint8(v2 >> 24)

	fmt.Printf("%+v\n", b2)
	// 所以最终将uint32转成[]byte数组输出为
	// [0 0 1 1]
}

// 这里是小端模式
// 在上面我们讲过，小端刚好和大端相反的，所以在转成小端模式的时候，只要将[]byte数组的下标首尾对换一下位置就可以了
func f3() {
	var v3 uint32
	var b3 [4]byte
	v3 = 257
	// 将 256转成二进制就是
	// | 00000000 | 00000000 | 00000001 | 00000001 |
	// | b3[0]    | b3[1]   | b3[2]    | [3]      | // 这里表示b3数组每个下标里面存放的值

	// 这里直接使用将uint32l强转成uint8
	// | 00000000 0000000 00000001 | 00000001  直接转成uint8后等于 1
	// |---这部分go在强转的时候扔掉---|
	b3[0] = uint8(v3)

	// | 00000000 | 00000000 | 00000001 | 00000001 | 右移8位 转成uint8后等于 1
	// 下面是右移后的数据
	// |          | 00000000 | 00000000 | 00000001 |
	b3[1] = uint8(v3 >> 8)

	// | 00000000 | 00000000 | 00000001 | 00000001 | 右移16位 转成uint8后等于 0
	// 下面是右移后的数据
	// |          |          | 00000000 | 00000000 |
	b3[2] = uint8(v3 >> 16)

	// | 00000000 | 00000000 | 00000001 | 00000001 | 右移24位 转成uint8后等于 0
	// 下面是右移后的数据
	// |          |          |          | 00000000 |
	b3[3] = uint8(v3 >> 24)

	fmt.Printf("%+v\n", b3)
	// 所以最终将uint32转成[]byte数组输出为
	// [1 1 0 0 ]
}
  ```


 	欢迎加入 dogo 技术交流群：437274005 点击右侧按钮快捷加入
[![dogo交流群](http://pub.idqqimg.com/wpa/images/group.png)](http://shang.qq.com/wpa/qunwpa?idkey=1720f7b75f19d952b80e10549ce35c6cc922c25b6505cd6f6680ac4fc7259484)
